### GC 时机

##### Minor GC   

- Eden区域满 不能为新对象分配内存空间

##### Full GC

- 调用System.gc时，系统建议执行Full GC，但是不必然执行
- 老年代空间不足 MetaSpace空间不足
- 通过Minor GC后进入老年代的对象大小大于老年代的可用内存
- 由Eden区、Survivor From区向Survivor To区复制时，对象大小大于Survivor To可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小



### CMS收集器

#### 年轻代

**并行、stop-the-world、复制**

#### 老年代

初始标记 --并发标记 -- 并行 再次标记  -- 并发清理

CMS 收集过程首先是一段小停顿 stop-the-world，叫做 **初始标记阶段（initial mark）**，用于确定 GC Roots。然后是 **并发标记阶段（concurrent mark）**，标记 GC Roots 可达的所有存活对象，由于这个阶段应用程序同时也在运行，所以并发标记阶段结束后，并不能标记出所有的存活对象。为了解决这个问题，需要再次停顿应用程序，称为 **再次标记阶段（remark）**，遍历在并发标记阶段应用程序修改的对象（标记出应用程序在这个期间的活对象），由于这次停顿比初始标记要长得多，**所以会使用多线程并行执行来增加效率**。 

再次标记阶段结束后，能保证所有存活对象都被标记完成，所以接下来的 **并发清理阶段（concurrent sweep）** 将就地回收垃圾对象所占空间 



